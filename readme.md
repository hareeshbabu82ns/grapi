<div align="center">

<a href="https://github.com/scalars/grapi"><img src="https://raw.githubusercontent.com/scalars/grapi/master/resources/logo-grapi.svg" width="50%"></a>

</div>

<br/>

> Businesses usually involving a broad spectrum of applications, that aren't integrated and requiring human intervention at almost every step of the process, this lack of integration and automation pretend to be solved trought an autogenerated GraphQL API Layer.
> **Grapi make GraphQL API integration simple and easy.**

## Installation
``` shell
yarn add @scalars/grapi
```
Or
``` shell
npm install @scalars/grapi
```

## Features
### Build GraphQL API with GraphQL SDL

SDL or Schema Definition Language is part of GraphQL Language, to define data and resolvers for the GraphQL API.

```graphql
# File schema.graphql
enum Gender {
    NO_GENDER,
    FEMALE,
    MALE
}
type Actor @Model( dataSource: "datasource", key: "Actor" ) {
    id: ID ! @unique
    name: String !
    gender: Gender
}
```

**Grapi** read SDL types and autogen resolvers for query and mutations on every model defined in SDL schema.

**Grapi for Typescript**
```shell
yarn init
yarn add @scalars/grapi @scalars/grapi-mongodb
yarn add ts-node apollo-server 
yarn add -D typescript
```

```typescript
// server.ts
import { readFileSync } from 'fs'
import { resolve } from 'path'
import { MongodbDataSourceGroup } from '@scalars/grapi-mongodb'
import { Grapi } from '@scalars/grapi'
import { ApolloServer } from 'apollo-server'

const getDataSource = async () => {
    const datasource = new MongodbDataSourceGroup(
        process.env.MONGO_URI,
        process.env.MONGO_DATA_BASE_NAME
    )
    await datasource.initialize()
    return datasource
}

const startGraphQLServer = async () => {
    const datasource = await getDataSource()
    const sdl = readFileSync( resolve( __dirname, 'schema.graphql' ) ).toString()
    const grapi = new Grapi( {
        sdl,
        dataSources: {
            datasource: ( args ) => datasource.getDataSource( args.key ),
        }
    } )
    const server = new ApolloServer( grapi.createApolloConfig() )
    server.listen().then( ( { url } ) => {
        console.info( `GraphQL Server On: ${ url }` )
        console.info( `Go To Browser And See PlayGround` )
    } )
}

startGraphQLServer()
```
Run server
```
yarn ts-node server.ts 
```

**Grapi for JavaScript**
```shell
yarn init
yarn add @scalars/grapi @scalars/grapi-mongodb
yarn add apollo-server
```

```javascript
// server.js
const { readFileSync } = require( 'fs' )
const { resolve } = require( 'path' )
const { MongodbDataSourceGroup } = require( '@scalars/grapi-mongodb' )
const { Grapi } = require( '@scalars/grapi' )
const { ApolloServer } = require( 'apollo-server' )

const getDataSource = async () => {
    const datasource = new MongodbDataSourceGroup(
        process.env.MONGO_URI,
        process.env.MONGO_DATA_BASE_NAME
    )
    await datasource.initialize()
    return datasource
}

const startGraphQLServer = async () => {
    const datasource = await getDataSource()
    const sdl = readFileSync( resolve( __dirname, 'schema.graphql' ) ).toString()
    const grapi = new Grapi( {
        sdl,
        dataSources: {
            datasource: ( args ) => datasource.getDataSource( args.key ),
        }
    } )
    const server = new ApolloServer( grapi.createApolloConfig() )
    server.listen().then( ( { url } ) => {
        console.info( `GraphQL Server On: ${ url }` )
        console.info( `Go To Browser And See PlayGround` )
    } )
}

startGraphQLServer()
```
Run server
```
node server.js
```

#### You can see the GraphQL server in action with

[ GraphQL PlayGround ](https://www.electronjs.org/apps/graphql-playground)

[ Insomnia ](https://insomnia.rest/download)

[ Graphiql ](https://github.com/graphql/graphiql)

Also Apollo Server offer a GraphQL Playground open your browser
[ http://localhost:4000 ]( http://localhost:4000 )

### Auto-Generated GraphQL Schema

Main characteristic of Grapi is autogen a GraphQL API with types defined in SDL, the previous schema create the next resolvers.

<br/>

#### Singular and Plural
```graphql
type Query {
    actor( where: ActorWhereUniqueInput ): Actor !
    actors( where: ActorWhereInput ): [ Actor ! ] !
}
```

#### Create - Update and Delete
```graphql
type Mutation {
    createActor( data: ActorCreateInput ): Actor !
    updateActor( where: ActorWhereUniqueInput data: ActorUpdateInput ): Actor !
    deleteActor( where: ActorWhereUniqueInput ): Actor !
}
```

These resolvers serve a schema in a GraphQL Server. 
Admit retrieve and save data from datasource provided 
by Mongo DataSource or your custom data source.


### RelationShip Made Easy

Database relationships are associations between tables. 
Grapi support autogen resolvers for queries and mutations in schema relations. 
It's easy create a complex server with data relations to retrieve and save data.

Next schema examples shows how to create
different relationship types.

> The ```key``` value in directive ```@Model```
> is the collection name in mongodb
> 
> The ```datasource``` value in directive ```@Model```
> is datasource alias defined in Grapi instance into dataSources object.
> That alias is arbitrary and is allow to named as you wish.
> The only condition is that in schema the alias has to be the same

#### One To One Unidirectional
```graphql
# File schema.graphql
type ActorToAddress implements Relation @config( 
    name: "ActorToAddress"
    foreignKey: { key: "city_id", side: Actor } 
)

type Actor @Model( dataSource: "datasource", key: "Actor" ) {
    id: ID ! @unique
    name: String !
    address: Address @relation( with: ActorToAddress )
}

type Address @Model( dataSource: "datasource", key: "Address" ) {
    id: ID ! @unique
    street: String !
    location: Json
}
```

#### One To One Bidirectional
```graphql
# File schema.graphql
type ActorToAddress implements Relation @config( 
    name: "ActorToAddress"
    foreignKey: { key: "city_id", side: Actor } 
)

type Actor @Model( dataSource: "datasource", key: "Actor" ) {
    id: ID ! @unique
    name: String !
    address: Address @relation( with: ActorToAddress )
}

type Address @Model( dataSource: "datasource", key: "Address" ) {
    id: ID ! @unique
    street: String !
    location: Json
    actor: Actor @relation( with: ActorToAddress )
}
```

#### One To Many Bidirectional
```graphql
# File schema.graphql
type VehiclesFromActor implements Relation @config( 
    name: "VehiclesFromActor"
    foreignKey: { key: "owner_car_id" } 
)

type Actor @Model( dataSource: "datasource", key: "Actor" ) {
    id: ID ! @unique
    name: String !
    vehicles: [ Vehicle ! ] ! @relation( with: VehiclesFromActor )
}

type Vehicle @Model( dataSource: "datasource", key: "Vehicle" ) {
    id: ID ! @unique
    trademark: String !
    model: String
    name: String
    owner: Actor @relation( with: VehiclesFromActor )
}
```

#### Many To Many
```graphql
# File schema.graphql
type MoviesFromActorManyToMany implements Relation @config( name: "MoviesFromActorManyToMany" )

type Actor @Model( dataSource: "datasource", key: "Actor" ) {
    id: ID ! @unique
    name: String !
    movies: [ Movie! ] ! @relation( with: MoviesFromActorManyToMany )
}

type Movie @Model( dataSource: "datasource", key: "Movie" ) {
    id: ID ! @unique
    title: String !
    actors: [ Actor ! ] ! @relation( with: MoviesFromActorManyToMany )
}
```

## Supported data-sources

<div>
    <a href="https://github.com/scalars/grapi/tree/main/grapi-mongodb">
        Grapi Mongodb
    </a>
</div>

## Inspired By

<div>

<a href="https://github.com/Canner/gqlify">
    <img 
        src="https://raw.githubusercontent.com/Canner/gqlify/master/resources/logo-pink.svg"
        width="10%">
</a>

</div>

## License

Apache-2.0

![footer banner](https://madrov.com/favicon.ico)


Madrov Team
